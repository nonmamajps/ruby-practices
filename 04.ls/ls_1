#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'etc'

BLANK_SIZE = 23
COL_FULL_SIZE = 3
STAT_BLANK_SIZE = 6

def check_option
  options = {}
  opt = OptionParser.new
  opt.on('-a') do |all_files|
    options[:all_files] = all_files
  end

  opt.on('-r') do |reverse_files|
    options[:reverse_files] = reverse_files
  end

  opt.on('-l') do |long_name_files|
    options[:long_name_files] = long_name_files
  end

  opt.parse!(ARGV)
  options
end

def fetch_files(all_files)
  option = all_files ? File::FNM_DOTMATCH : 0
  Dir.glob('*', option)
end

def files_to_matrix(options)
  files = fetch_files(options[:all_files])
  files = files.reverse if options[:reverse_files]
  sliced_files = files.each_slice(COL_FULL_SIZE).to_a
  # 配列内の要素が3つに揃うように空白を追加
  sliced_files.each do |cols|
    cols.concat([''] * (COL_FULL_SIZE - cols.size)) if cols.size < COL_FULL_SIZE
  end
  sliced_files
end

def print_file(matrix)
  # 各要素を縦に並べる
  matrix.transpose.each do |rows|
    print_file_to_display(rows)
  end
end

def print_file_to_display(files)
  max_length = files.map(&:length).max
  files.each do |file|
    print "#{file.ljust(max_length + 1)}#{' ' * (BLANK_SIZE - max_length)}"
  end
  puts
end

def file_type(stat)
  case stat.ftype
  when 'file' then '-'
  when 'directory' then 'd'
  when 'link' then 'l'
  when 'characterSpecial' then 'c'
  when 'blockSpecial' then 'b'
  when 'fifo' then 'f'
  when 'socket' then 's'
  else
    'unknown'
  end
end

def default_permission(stat)
  case stat
  when 0 then '---'
  when 1 then '--x'
  when 2 then '-w-'
  when 3 then '-wx'
  when 4 then 'r--'
  when 5 then 'r-x'
  when 6 then 'rw-'
  when 7 then 'rwx'
  end
end

def permission(stat)
  permissions = format('%o', stat.mode.to_i)[-3..]
  owner_perm = default_permission(permissions[0].to_i)
  group_perm = default_permission(permissions[1].to_i)
  other_perm = default_permission(permissions[2].to_i)
  "#{owner_perm}#{group_perm}#{other_perm}"
end

def file_information(options)
  file_list = fetch_files(options[:all_files])
  file_information = file_list.map { |name| File.lstat(name) }
  [file_list, file_information]
end

def print_of_l_option(file_list, file_information)
  total_blocks = file_information.sum(&:blocks)
  puts "total #{total_blocks}"
  file_list.each_with_index do |name, idx|
    stat = file_information[idx]
    file_type = file_type(stat)
    permission = permission(stat)
    print = "#{file_type}"\
    "#{permission} "\
    "#{stat.nlink.to_s.rjust(2)} "\
    "#{Etc.getpwuid(stat.uid).name}  "\
    "#{Etc.getgrgid(stat.gid).name}"\
    "#{stat.size.to_s.rjust(STAT_BLANK_SIZE)} "\
    "#{stat.atime.mon.to_s.rjust(2)} "\
    "#{stat.atime.day.to_s.rjust(2)} "\
    "#{stat.atime.strftime('%H:%M')} "
    print += FileTest.symlink?(name) ? "#{name} -> #{File.readlink(name)}" : name
    puts print
  end
end

options = check_option
matrix = files_to_matrix(options)
if options[:long_name_files]
  file_list, file_information = file_information(options)
  print_of_l_option(file_list, file_information)
else
  print_file(matrix)
end
